package pattern.typing

/**
  * パターン20: 静的な式の型を計算する
  *
  * "型安全性を保証するために最初にしなければいけないことは、すべての式と式要素の型を計算することです"
  *
  * "式の型を計算するとは、すべての要素の型とすべての演算結果の型を計算するという問題に他なりません"
  *
  * true, false: Boolean
  * 文字リテラル: char
  * 整数リテラル: int
  * 浮動小数点リテラル: float
  * <識別子>: <識別子>によって特定される変数の型
  * !<式>: boolean
  * <式>.<識別子>: <識別子>によって特定されるフィールドの型
  * a[<式>]: arrayの要素型
  * f(<式>): 関数fの戻り値の型
  * <式> 算術演算子 <式>: <式>の型
  * <式> 関係演算子 <式>: boolean
  * <式> 等値演算子 <式>: boolean
  *
  * "この計算はかなり退屈です。というのも、被演算数の型がすべて同じだと仮定しているからです。(略)
  *  後から本パターンの上に型昇格と型検査の処理を継ぎ足します"
  *
  * 実装
  *
  * "1回目の木走査では記号を定義し、2回目の木走査は記号を解決して式の型を計算します"
  *
  * メモ：
  * サンプルコードが、Symbol, Type, Scopeの責務をすべてごちゃまぜにしているクソコードなので責務分離、上手くいった
  *
  */
package object pattern20_computetype