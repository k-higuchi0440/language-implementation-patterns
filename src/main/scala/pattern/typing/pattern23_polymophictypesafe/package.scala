package pattern.typing

/**
  * パターン23: 多態性型安全性を守らせる
  *
  * "本パターンは、C++のようなオブジェクト指向言語の中でオブジェクトのポインタを代入する場合に、
  *  型互換性のない型を検出します"
  *
  * "多態性とは、1つのポインタが複数の型のオブジェクトを参照できるという性質を表します。
  *  これとは対照的に、Cのポインタ代入では型を厳密に一致させないといけません"
  *
  * "ポインタを使わないと多態性の意味がないので、本章の中でずっと使ってきたCymbol言語に
  *  ポインタを追加しないといけません（略）
  *  オブジェクトポインタ代入の中で型検査を実際に行うには、
  *  次のような構成体を使ってCymbolを拡張する必要があります"
  *
  * ・ 単一継承を備えたクラス（構造体は取り除きます）
  * ・ 基本型とクラス型を指すためのポインタ
  * ・ 「アドレス計算」演算子である &
  * ・ 「ポインタ参照渡し」演算子である *
  * ・ 「オブジェクトポインタ経由のメンバアクセス」演算子である ->
  *
  * "もっと楽をするには、抽象構文木を構築するときに配列参照を正規化して
  *  等価なポインタ計算へと置き換えることができます（a[i]は*(a+i)になります）。
  *  ポインタ経由のメンバアクセスでも同じことをします（p->xは(*p).xになります）。
  *  こうすると、抽象構文木にはポインタ計算しか存在しないため、
  *  抽象構文木の定義パスと型安全性パスは新しい構文を気に掛ける必要がありません"
  */
package object pattern23_polymophictypesafe