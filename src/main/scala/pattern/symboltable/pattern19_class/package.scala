package pattern.symboltable

/**
  * パターン19: クラスのための記号表
  *
  * "本パターンは、単一継承を持ち入れ子のないクラスを対象にして、記号を記録してスコープ木を構築します"
  *
  * メンバアクセス式を解決する
  *
  * クラスの中にメンバがなければ、スーパークラスのメンバを参照する
  *
  * 前方参照を扱う
  *
  * "クラスの中では前方参照を使うこともできます。前方参照では、参照先のメソッドや型、
  *  変数が同じ入力ファイルの中で参照よりも後ろの位置で定義されています"
  *
  *  "これらの前方参照を扱うためには、"参照よりも後ろに"ある定義を探して"後ろの方を"走査することもできますが、
  *   もっと簡単な方法があります"
  *
  *  "入力を処理する"フェーズを"2つ作って、1つを記号を定義するパスにして、もう1つを記号を解決するパスにする方法です"
  *
  *  "困ったことに、2つのフェーズに分割するとデータのやり取りという課題が新たに発生します。
  *   記号参照を解決するためには現スコープを知らないといけませんが、
  *   現スコープを計算するのは定義フェーズのときだけです。(略)
  *   情報をしまうのに適した場所は、入力を表す抽象構文木の中です"
  *
  *   "定義フェーズでは、いつも通りに現スコープを追跡して、関連する抽象構文木ノードの中に現スコープを記録します。
  *    記号を定義するときには、その結果のsymbolオブジェクトも抽象構文木の中に記録した方がいいでしょう。
  *    すると、解決フェーズではスコープ情報と記号定義を探して木の中を検索することができます。
  *    記号参照を解決するときには、抽象構文木の中に検索結果を放り込むこともします。
  *    それ以降のどの木処理フェーズでも、分析や変換をするためにほぼ間違いなくこの記号ポインタを使うことになるからです"
  *
  */
package object pattern19_class
