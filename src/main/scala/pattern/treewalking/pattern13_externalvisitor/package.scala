package pattern.treewalking

/**
  * パターン13: 外部木訪問器
  *
  * "本パターンは、同じ作業に関係するすべての木走査コードを1つの訪問器クラスの中に集めてカプセル化します"
  *
  * "訪問器は、抽象構文木ノード定義の外で木走査コードとアクション実行コードを結びつけます。
  *  その結果、抽象構文木クラス定義を変更しなくとも木走査器の機能を変更できますし、さらには、
  *  訪問器を実行中に切り替えることさえできます。
  *  外部訪問器は、非均質抽象構文木ノードと均質抽象構文木ノードのどちらも走査できます"
  *
  *  "本パターンを実装するには2つの手法があります"
  *
  * 1. ノード型に基づいて訪問器を切り替える
  *
  * "伝統的な訪問器パターンの実装では、
  *  1つ1つの抽象構文木ノードの中にある「2重振分け」(double-dispatch)メソッドが大きな役割を果たしています。(略)
  *  これを動かすには、2重振分けメソッドvisit()のシグネチャを汎用ノードの中で定義しないといけません"
  *
  *  "この訪問器実装では非均質ノードでないといけませんし、悲しいかな、
  *   2重振分けメソッドvisit()のせいで抽象構文木ノードから完全に独立してはいません"
  *
  * 2. 独立した訪問器を構築するために字句型に基づいて訪問器を切り替える
  *
  * "抽象構文木ノード型をやめて字句型に基づいて切り替えるようにすれば、
  *  抽象構文木ノードごとにvisit()メソッドを用意しないで済みます。
  *  代わりに使う新しい振分けメソッドは、訪問器の中に1つだけあります"
  *
  */
package object pattern13_externalvisitor
